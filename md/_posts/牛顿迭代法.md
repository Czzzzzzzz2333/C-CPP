---
title: 牛顿迭代法
categories: 
- Algorithm
tags: 
- 博客
---
牛顿迭代法（Newton's method）又称为牛顿-拉夫逊（拉弗森）方法（Newton-Raphson method），它是牛顿在17世纪提出的一种在实数域和复数域上近似求解方程的方法。

当然，牛顿迭代法也是已知已知的实现求方根最快的方法之一。

大家都知道，五次方程无根式解，但是用途却很多。
而牛顿迭代法的出现正好解决了这个问题。

牛顿迭代法就是不断求导数，请看下图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/201908232007000.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70)
大致推导：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190823201506861.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI2MjEy,size_16,color_FFFFFF,t_70)
牛顿迭代法求方根：

```cpp
int mySqrt(int x){
    long r = x;
	while(r * r > x)
	{
		r = (r + x / r) / 2;//迭代
	}
	return (int)r;
}
```

雷神之锤III的源码

```cpp
float Q_rsqrt( float number ) { 
    long i; float x2, y; const float threehalfs = 1.5F;
    x2 = number * 0.5F; 
    y = number; 
    i = * ( long * ) &y; // evil floating point bit level hacking 
    i = 0x5f3759df - ( i >> 1 ); // what the fuck? 
    y = * ( float * ) &i; 
    y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration 
    // y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed
    #ifndef Q3_VM #
    ifdef __linux__ assert( !isnan(y) ); // bk010122 - FPE?
    #endif
    #endif return y; 
}
```
参考[https://www.cnblogs.com/ECJTUACM-873284962/p/6536576.html](https://www.cnblogs.com/ECJTUACM-873284962/p/6536576.html)

牛顿迭代法求方程的根没有固定的模板。
需根据不同要求进行解答。

可以看看hduoj 2199 [传送门](http://acm.hdu.edu.cn/showproblem.php?pid=2199)
题目的大概意思是：对于8 * x *x *x *x + 7 * x *x *x + 2 * x *x + 3 * x + 6 = y ，给定y，要在1~100范围内找到合适的x使得等式成立。
可以用二分，也可以用牛顿迭代。

```cpp
#include <bits/stdc++.h>
//#include <iomanip>
using std::cin;
using std::cout;
using std::endl;

double y;
const double EPS = 1e-6;

//#define F(x) 8 * x *x *x *x + 7 * x *x *x + 2 * x *x + 3 * x + 6 - y
//#define F1(x) 32 * x *x *x + 21 * x *x + 4 * x + 3

#define F(x) 8 * x *x *x *x + 7 * x *x *x + 2 * x *x + 3 * x + 6 - y
#define F1(x) 32 * x *x *x + 21 * x *x + 4 * x + 3

double Newton(double x) {
  int k = 1;
  while (fabs(F(x)) > EPS) {
    x -= (F(x)) / (F1(x));
    k++;
    if (k > 30)
      return -1;
  }
  return x;
}

int main() {
  std::ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
  cout << std::fixed;
  int T;
  cin >> T;
  while (T--) {
    cin >> y;
    double z;
    bool flag = false;
    for (double i = 0.0; i < 100; i++) {
      z = Newton(i);
      if (z <= 100 && z >= 0) {
        flag = true;
        break;
      }
    }
    if (flag==false) {
      cout << "No solution!" << endl;
    } else {
      cout << std::setprecision(4) << z << endl;
    }
  }
  return 0;
}
```

更详细的请参考：
[https://www.matongxue.com/madocs/205/](https://www.matongxue.com/madocs/205/)