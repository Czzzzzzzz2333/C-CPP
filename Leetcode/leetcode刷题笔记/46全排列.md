## 原题

> 给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。
>
> **示例:**
>
> > 输入: [1,2,3]
> > 输出:
> > [
> >   [1,2,3],
> >   [1,3,2],
> >   [2,1,3],
> >   [2,3,1],
> >   [3,1,2],
> >   [3,2,1]
> > ]
> >
> > 来源：力扣（LeetCode）
> > 链接：https://leetcode-cn.com/problems/permutations

## 解法

### 1. 直接调库

C++的STL提供了 **next_permutation()**和**prev_permutation()**

**next_permutation()作用是寻找所有比当前排列大的排列，顺序是从小到大。**

**prev_permutation()作用是寻找所有比当前排列小的排列，顺序是从大到小。**

````cpp
class Solution {
public:
  vector<vector<int>> permute(vector<int> &nums) {
    sort(nums.begin(), nums.end());
    vector<vector<int>> vec;
    vec.emplace_back(nums);
    while (next_permutation(nums.begin(), nums.end())) {
      vec.emplace_back(nums);
    }
    return vec;
  }
};
````

当然，直接用库还是不太好的🙅。

顺便我们看下 **next_permutation()** 的实现。

````cpp
template<class BidirIt>
bool next_permutation(BidirIt first, BidirIt last)
{
    if (first == last) return false;
    BidirIt i = last;
    if (first == --i) return false;
 
    while (true) {
        BidirIt i1, i2;
 
        i1 = i;
        if (*--i < *i1) {
            i2 = last;
            while (!(*i < *--i2))
                ;
            std::iter_swap(i, i2);
            std::reverse(i1, last);
            return true;
        }
        if (i == first) {
            std::reverse(first, last);
            return false;
        }
    }
}
````

### 2.递归解决

以 ***[1, 2, 3]*** 为例：

以 ***1*** 开头的排列：`[1, 2, 3], [1, 3, 2]`;

以 ***2***开头的排列：`[2, 1, 3], [2, 3, 1]`;

以 ***3***开头的排列：`[3, 1, 2], [3, 2, 1]`;

我们得出这样一颗树：

![结构](https://imgkr.cn-bj.ufileos.com/edccf46a-aa2a-4897-85d4-e5cc4b0e96bf.png)

我们根据这颗树，可以写出如下代码：

````cpp
class Solution {
public:
  vector<vector<int>> permute(vector<int> &nums) {
    vector<vector<int>> vec;
    int size = nums.size();
    for (int i = 0; i < size; ++i) {
      for (int j = 0; j < size; ++j) {
        for (int k = 0; k < size; ++k) {
          if (nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k]) {
            vec.push_back({nums[i], nums[j], nums[k]});
          }
        }
      }
    }
    print(vec);
    return vec;
  }

  void print(vector<vector<int>> &vec) {
    for (decltype(vec.size()) i = 0; i < vec.size(); ++i) {
      for (decltype(i) j = 0; j < vec[i].size(); ++j) {
        cout << vec[i][j] << " ";
      }
      cout << endl;
    }
  }
};
````

好了，我们解决了数组长度为 **3** 的全排列，有三重循环，那么如果数组长度为 **4，5，……** ，又该怎么做？因为数组长度是不定的，所以这种方法不能用了，而且，也没人会去*傻傻的*写超级多重循环吧！

我们发现这个过程好像跟 **“深搜”** 挺相似的，没错，就是 ***dfs*** ，那么我们就写个***dfs***不就好了吗？

````cpp
class Solution {
public:
  vector<vector<int>> permute(vector<int> &nums) {
    vector<vector<int>> vec;
    int size = nums.size();
    vector<bool> flag(size, false);
    vector<int> temp;
    recusive(size, nums, temp, vec, flag, 0);
    return vec;
  }

  /**
   * size是nums的长度,
   * temp做临时vector, 保存每次搜索结束后全排列的结果,
   * vec返回给测评机的二维vector,
   * flag记录当前搜索过程中该数据是否使用了,
   * cnt记录搜索的深度。
   **/
  void recusive(int size, vector<int> &nums, vector<int> &temp,
                vector<vector<int>> &vec, vector<bool> &flag, int cnt) {
    if (cnt == size) {
      vec.emplace_back(temp);
      return;
    }
    for (int i = 0; i < size; ++i) {
      // 如果没有使用过
      if (!flag[i]) {
        temp.emplace_back(nums[i]);
        flag[i] = true;
        // recusive之前是 “递”
        recusive(size, nums, temp, vec, flag, cnt + 1);
        // recusive之后是 “归”
        flag[i] = false;
        temp.erase(temp.end() - 1); // 回溯
      }
    }
  }
};
````

## 总结

看到网上的一种写法，就想起了 **荀子《劝学》** 中的一句名言 ***故不登高山，不知天之高也；不临深溪，不知地之厚也；不闻先王之遗言，不知学问之大也。***

附带解法：

````cpp
class Solution {
public:
  vector<vector<int>> permute(vector<int> &nums) {
    vector<vector<int>> res;
    dfs(res, 0, nums);
    return res;
  }
  void dfs(vector<vector<int>> &res, int start, vector<int> &nums) {
    if (start == nums.size()) {
      res.push_back(nums);
      return;
    }
    for (int i = start; i < nums.size(); i++) {
      swap(nums[start], nums[i]);
      dfs(res, start + 1, nums);
      swap(nums[start], nums[i]);
    }
    return;
  }
};
````

我肯定是想不到这样子写的👀

不断学习，任重而道远。

## 诗情画意

> <center>满江红·写怀</center>
> <center>岳飞</center>
> <center>怒发冲冠，凭栏处，潇潇雨歇。抬望眼，仰天长啸，壮怀激烈。三十功名尘与土，八千里路云和月。莫等闲，白了少年头，空悲切！</center>
> <center>靖康耻，犹未雪。臣子恨，何时灭！驾长车，踏破贺兰山阙。壮士饥餐胡虏肉，笑谈渴饮匈奴血。待从头，收拾旧山河，<br />朝天阙。</center>