## 原题

> 给出一个区间的集合，请合并所有重叠的区间。
>
> **示例 1:**
>
> > <pre><strong>输入:</strong> [[1,3],[2,6],[8,10],[15,18]]
> > <strong>输出:</strong> [[1,6],[8,10],[15,18]]
> > <strong>解释:</strong> 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
> > </pre>
>
> **示例 2:**
>
> > <pre><strong>输入:</strong> [[1,4],[4,5]]
> > <strong>输出:</strong> [[1,5]]
> > <strong>解释:</strong> 区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre>

## 解法

此题，难度不算很大。

我们要合并两个区间，必须满足：

1. 第一个区间左边的数字肯定要小于第二个区间左边的数字；
2. 第一个区间右边的数字肯定要大于第二个区间左边的数字；

合并区间：

1. 满足合并区间的条件后；
2. 新的区间左边的数字为原第一个区间左边的数字，新区间右边的数字为 **原第一个区间右边数字和原第二个区间右边数字的最大值。**

举例：

`[0, 4], [3, 5]`

1. 0 <= 3
2. 4 >= 3

新区间为[0, 5]。

`[0, 5], [3, 4]`

1. 0 <= 3
2. 5 >= 3

新区间为[0, 5]

第一个条件很好满足，我们把二维向量按照第一个数字排序就好了。

第二个条件需要我们自己判断。

````cpp
class Solution {
public:
  vector<vector<int>> merge(vector<vector<int>> &intervals) {
    int size = intervals.size();
    vector<vector<int>> ans;
    sort(intervals.begin(), intervals.end());
    int i;
    for (i = 0; i < size; ++i) {
      // 保存当前区间左边的数字和右边的数字
      int left = intervals[i][0], right = intervals[i][1];
      while (i < size - 1 && right >= intervals[i + 1][0]) {
        // 我们要找到一个最新区间右边的数字
        right = max(right, intervals[i + 1][1]);
        ++i;
      }
      ans.push_back({left, right});
    }
    return ans;
  }
};
````

***特别注意的是：我们的目的是合并所有可以合并的区间，不是找到两个区间可以合并就直接先合并这两个区间！***

## 总结

一开始写的时候，自己绕进去了，只想着遇到区间可以合并，合并以后就把新的区间保存。

关键是，自己用来测试的数据偏偏又是那么的 **巧合** ，都是连续的两个区间合并，没有比两个多区间可以合并，结果折腾了半天。

多看题目，多想题目，在做题之前把集中自己的精力，毕竟磨刀不误砍柴功。

献丑了！

## 诗情画意

> <center>使至塞上</center>
> <center>王维</center>
> <center>单车欲问边，属国过居延。
> </center><center>征蓬出汉塞，归雁入胡天。
> </center><center>大漠孤烟直，长河落日圆。
> </center><center>萧关逢侯骑，都护在燕然。</center>

