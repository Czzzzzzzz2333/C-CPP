## 原题

> 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
>
> 示例：
>
> > 输入：n = 3
> > 输出：[
> >        "((()))",
> >        "(()())",
> >        "(())()",
> >        "()(())",
> >        "()()()"
> >      ]
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/generate-parentheses

## 题解

我们看下当**n = 3**时的二叉树结构

![](https://imgkr.cn-bj.ufileos.com/5937fbd2-9013-4147-87e6-472c5036e480.svg)

由此二叉树结构图我们可以得知的信息：

+ 当**左括号小于n**时：
  + 先产生**左分支(左括号小于n)**；
  + **左分支(左括号小于n)且当前左分支已经产生**这两个条件不满足时，产生**右分支(左括号大于右括号)**；
  + 当产生**左分支条件(左括号小于n)**和**右分支条件(左括号大于右括号)**不满足时，回溯到可以继续产生分支的节点。
+ 结束寻找的条件是左括号个数等于**n**并且右括号个数等于**n**

思路就是不断搜索，显然跟二叉树的**深度遍历**有点像。

**深度遍历**一般用递归，显然我们已经分析出了递归结束的条件***(左括号个数等于n并且右括号个数等于n)***

````c++
if (左括号个数 == n && 右括号个数 == n) {
    vec.emplace_back(当前满足条件的括号匹配);
    return;
}
````

由此可得知，我们的递归函数需要的变量**左括号个数left**，**右括号个数right**，题目给的**n**，保存**当前满足条件的括号匹配str**，还有一个**返回给测评机的字符串向量vec**。

````c++
class Solution {
public:
  vector<string> generateParenthesis(int n) {
    vector<string> vec;
    if (n == 0) {
      return vec;
    }
    recursion(vec, "", 0, 0, n);
    return vec;
  }

  void recursion(vector<string> &vec, string str, int left, int right, int n) {
    //递归结束条件
    if (left == n && right == n) {
      vec.emplace_back(str);
      return;
    }
    if (left < n) {
      recursion(vec, str + "(", left + 1, right, n);
    }
    if (left > right) {
      recursion(vec, str + ")", left, right + 1, n);
    }
  }
};
````

因为，最开始的时候**左括号和右括号都没有，所以传0进去，满足要求的括号匹配也没有，传空字符串就好了**。

深搜题：[全排列](https://leetcode-cn.com/problems/permutations/)

## 总结

以后遇到，类似***`所有可能，全排列……`***这种题，首先要想到的是递归！

既然要用递归，画个二叉树，递归结构就搞的清清楚楚了。

感觉题解写的挺烂的，毕竟本人也是个菜鸟，多多担待。

## 诗情画意

> <center>南乡子·登京口北固亭有怀</center>
>
> <center>辛弃疾</center>
>
> <center>何处望神州？满眼风光北固楼。千古兴亡多少事？悠悠。不尽长江滚滚流。</center>
>
> <center>年少万兜鍪，坐断东南战未休。天下英雄谁敌手？曹刘。生子当如孙仲谋。</center>