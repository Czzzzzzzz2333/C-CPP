## 原题

> 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
>
> ![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)
>
> 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。
>
> 示例:
>
> > 输入: [0,1,0,2,1,0,1,3,2,1,2,1]
> > 输出: 6
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/trapping-rain-water

## 一. 接雨水

### 最初想法

想要接到雨水就要，就要保证是个“凹”形状的容器，而接到的雨水的多少，就要看“凹”形容器的最短边。

那么我们就找这样一个“尽可能大“的“凹”形就好了。

怎样找到这个最大的“凹”形？

我们找到当前位置左边最高的柱子，再找到右边最高的柱子，这不就是最大的“凹”吗？

当然不是每次都能找到这个“凹”形的！

例1：

`当我们遍历到第二个柱子的高度(1)时,我们找当前柱子左边的最高柱子,是本身,找当前柱子右边的最高柱子(3),是第八根柱子,显然,没有构成"凹"形.`

例2：

`当我们遍历到第三根柱子的高度(0)时,左边最高的柱子是第二根(1),右边最高的柱子是第四根(2),显然,构成了一个"凹"形.`

当我们找到了“凹”形，就可以计算可以接多少雨水了。

按照例2，我们可以接到的雨水为**min(左边最高柱子高度, 右边最高柱子高度)**

但是，这个好像还是有点问题！

例3：

`当我们遍历到第五根柱子高度(1)时,左边最高柱子是第四根(2),右边最高柱子是第八根(3),显然构成"凹"形`

但是这个能接到的雨水是**min(左边最高柱子高度, 右边最高柱子高度)**吗？

显然不是的。

综上得知：

**接到的雨水 = min(左边最高柱子高度, 右边最高柱子高度) - 当前柱子的高度**

根据得出的结论，我们容易写出代码。

````c++
class Solution {
public:
  int trap(vector<int> &height) {
    int size = height.size();
    int ans = 0;

    for (int i = 0; i < size; ++i) {
      int max_left = 0, max_right = 0;

      for (int j = 0; j <= i; ++j) {
        max_left = max(height[j], max_left);
      }

      for (int j = i; j < size; ++j) {
        max_right = max(height[j], max_right);
      }

      ans += min(max_left, max_right) - height[i];
    }
    return ans;
  }
};
````

但是，这个貌似超时了。

我们试下可不可以“卡”过去，第一根柱子和最后一根柱子，我们不需要遍历，因为这两根柱子不可能构成“凹”形的！

````c++
class Solution {
public:
  int trap(vector<int> &height) {
    int size = height.size();
    int ans = 0;

    for (int i = 1; i < size - 1; ++i) {
      int max_left = 0, max_right = 0;

      for (int j = 0; j <= i; ++j) {
        max_left = max(height[j], max_left);
      }

      for (int j = i; j < size; ++j) {
        max_right = max(height[j], max_right);
      }

      ans += min(max_left, max_right) - height[i];
    }
    return ans;
  }
};
````

> 执行结果：通过
>
> 执行用时 :848 ms, 在所有 C++ 提交中击败了5.03%的用户
>
> 内存消耗 :7 MB, 在所有 C++ 提交中击败了100.00%的用户

时间复杂度：O(n)

空间复杂度：O(1)

好了，勉强过了，这么慢的代码，怎么符合大家的形象呢？

### 解法优化

想法挺好的，也是正确的。但是，我们容易看到每次遍历柱子时，都要找一遍左边最高柱子，右边最高柱子。

为什么我们不能把**每个位置对应的左右最高的两个柱子存起来**，要用拿来用就行了，这样我们就不要每次去找了。

这就是所谓的**空间换时间！**

````c++
class Solution {
public:
  int trap(vector<int> &height) {
    if (height.size() == 0) {
      return 0;
    }
    int ans = 0;
    int size = height.size();
    vector<int> left_max(size), right_max(size);
    left_max[0] = height[0];
    for (int i = 1; i < size; ++i) {
      left_max[i] = max(height[i], left_max[i - 1]);
    }
    right_max[size - 1] = height[size - 1];
    for (int i = size - 2; i >= 0; --i) {
      right_max[i] = max(height[i], right_max[i + 1]);
    }
    print(left_max);
    print(right_max);

    for (int i = 1; i < size - 1; ++i) {
      ans += min(left_max[i], right_max[i]) - height[i];
    }

    return ans;
  }

  void print(vector<int> &nums) {
    int len = nums.size();
    for (auto i : nums) {
      cout << i << " ";
    }
    cout << endl;
  }
};
````

时间复杂度：O(n)

空间复杂度：O(n)

## 二. 总结

试试用栈做这道题？

## 诗情画意

<center>南园十三首·其五</center>

<center>李贺</center>

<center>男儿何不带吴钩，收取关山五十州。</center>

<center>请君暂上凌烟阁，若个书生万户侯？</center>





